extends eelixir

snippet ot
	{
		${0}
	}
snippet t1
	{${0}}
snippet t2
	{${1}, ${0}}
snippet t3
	{${1}, ${2}, ${0}}
snippet t4
	{${1}, ${2}, ${3}, ${0}}
snippet do
	do
		${0:${VISUAL}}
	end
snippet put IO.puts
	IO.puts("${0}")
snippet ins IO.inspect
	IO.inspect(${0})
snippet insl IO.inspect with label
	IO.inspect(${0}label: "${1:label}")
snippet if if .. do .. end
	if ${1} do
		${0:${VISUAL}}
	end
snippet if: if .. do: ..
	if $1, do: ${0}
snippet ife if .. do .. else .. end
	if $1 do
		${2:${VISUAL}}
	else
		${0}
	end
snippet ife: if .. do: .. else:
	if $1, do: ${2}, else: ${0}
snippet unless unless .. do .. end
	unless ${1} do
		${0:${VISUAL}}
	end
snippet unless: unless .. do: ..
	unless $1, do: ${0}
snippet unlesse unless .. do .. else .. end
	unless $1 do
		${2:${VISUAL}}
	else
		${0}
	end
snippet unlesse: unless .. do: .. else:
	unless $1, do: ${2}, else: ${0}
snippet cond
	cond do
		${1} ->
		${0:${VISUAL}}
	end
snippet case
	case ${1} do
		${2} -> ${0}
	end
snippet for
	for ${1:item} <- ${2:items} do
		${0}
	end
snippet for:
	for ${1:item} <- ${2:items}, do: ${0}
snippet fori
	for ${1:item} <- ${2:items}, into: ${3} do
		${0}
	end
snippet wi
	with ${1:item} <- ${2:items} do
		${0}
	end
snippet wie
	with(
		${1:item} <- ${2:items}
	) do
		${3}
	else
		${4} ->
			${0}
	end
snippet sp
	@spec ${1:name}(${2:args}) :: ${3:returns}
snippet op
	@opaque ${1:type_name} :: ${2:type}
snippet ty
	@type ${1:type_name} :: ${2:type}
snippet typ
	@typep ${1:type_name} :: ${2:type}
snippet cb
	@callback ${1:name}(${2:args}) :: ${3:returns}
snippet df
	def ${1:name}, do: ${2}
snippet dfw
	def ${1:name}(${2:args}) when ${3:guard}, do:
snippet def
	def ${1:name} do
		${0}
	end
snippet defd
	@doc """
	${1:doc string}
	"""
	def ${2:name} do
		${0}
	end
snippet defs
	@spec ${1:name}(${2:arg types}) :: ${3:no_return}
	def $1(${4:args}) do
		${0}
	end
snippet defsd
	@doc """
	${1:doc string}
	"""
	@spec ${2:name}(${3:arg types}) :: ${4:no_return}
	def $2(${5:args}) do
		${0}
	end
snippet defw
	def ${1:name}(${2:args}) when ${3:guard} do
		${0}
	end
snippet defim
	defimpl ${1:protocol_name}, for: ${2:data_type} do
		${0}
	end
snippet defma
	defmacro ${1:name} do
		${0}
	end
snippet dfma
	defmacro ${1:name}, do: ${0}
snippet defmo
	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		${0}
	end
snippet %M
	%__MODULE__{
		${1:key_name}: ${2:value}
	}
snippet enfk
	@enforce_keys [:${1:key_name}]
snippet dfp
	defp ${1:name}, do: ${2}
snippet dfpw
	defp ${1:name}(${2:args}) when ${3:guard}, do: ${4}
snippet defp
	defp ${1:name} do
		${0}
	end
snippet defpw
	defp ${1:name}(${2:args}) when ${3:guard} do
		${0}
	end
snippet defpr
	defprotocol ${1:name}, [${0:function}]
snippet defr
	defrecord ${1:record_name}, ${0:fields}
snippet doc
	@doc """
	${0}
	"""
snippet docs
	@doc ~S"""
	${0}
	"""
snippet docf
	@doc false
snippet im
	@impl true
snippet fn
	fn ${1:args} -> ${0} end
snippet mdoc
	@moduledoc """
	${0}
	"""
snippet mdocs
	@moduledoc ~S"""
	${0}
	"""
snippet mdocf
	@moduledoc false
snippet rec
	receive do
		${1} ->
			${0}
	end
snippet req
	require ${0:Logger}
snippet imp
	import ${0:module_name}
snippet ali
	alias ${0:module_name}
snippet alis
	alias ${1:module_name}, as: ${0}
snippet test
	test "${1:test name}" do
		${0}
	end
snippet testc
	test "${1:test_name}", ctx do
		${0}
	end
snippet testa
	test "${1:test_name}", %{${2:arg: arg}} do
		${0}
	end
snippet des
	describe "${1:test group subject}" do
		${0}
	end
snippet destag
	@describetag :${1:describe tag}
snippet mtag
	@moduletag :${1:module tag}
snippet dt
	doctest ${1:filename}
snippet tp
	@tag :pending
snippet exunit
	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		use ExUnit.Case, async: true

		${0}
	end
snippet setup
	setup do
		${1}
	end
snippet setupa
	setup_all do
		${1}
	end
snippet try try .. rescue .. end
	try do
		${1:${VISUAL}}
	rescue
		${2} -> ${0}
	end
snippet pry
	require IEx; IEx.pry
	${0}
snippet ppry
	|> (fn x -> require IEx; IEx.pry; x end).()${0}
snippet qu
	quote do
		${1}
	end
snippet beh
	@behaviour ${1:Mix.Task}
	${0}
snippet p
	|> ${0}
snippet pe pipe to each
	|> Enum.each(fn ${1} -> ${0} end)
snippet pm pipe to map
	|> Enum.map(fn ${1} -> ${0} end)
snippet pf pipe to filter
	|> Enum.filter(fn ${1} -> ${0} end)
snippet pr pipe to reduce
	|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> ${0} end)
snippet pi pipe to inspect
	|> IO.inspect()
snippet pil pipe to inspect with label
	|> IO.inspect(label: "${1:label}")
snippet cs
	@doc false
	def child_spec(${1:_opts}) do
		%{
			id: __MODULE__,
			start: {__MODULE__, :start_link, ${2:[]}},
			restart: ${3::permanent},
			shutdown: ${4:5000},
			type: ${5::worker}
		}
	end
snippet genserver basic genserver structure
	use GenServer

	@doc false
	def start_link(init_args) do
		GenServer.start_link(__MODULE__, init_args, name: __MODULE__)
	end

	@impl true
	def init(state) do
		{:ok, state}
	end
snippet super basic supervisor structure
	use Supervisor

	@doc false
	def start_link(init_args) do
		Supervisor.start_link(__MODULE__, init_args, name: __MODULE__)
	end

	@impl true
	def init(_init_args) do
		children = [${1}]
		Supervisor.init(children, strategy: :one_for_one)
	end
snippet dynsup basic dynamicsupervisor
	use DynamicSupervisor
	
	def start_link(init_arg) do
		DynamicSupervisor.start_link(__MODULE__, init_arg, name: __MODULE__)
	end
	
	@impl true
	def init(_init_arg) do
		DynamicSupervisor.init(strategy: one_for_one)
	end
snippet regi basic registry
	def start_link do
		Registry.start_link(keys: :unique, name: __MODULE__)
	end
	
	def via_tuple(key) do
		{:via, Registry, {__MODULE__, key}}
	end

	def child_spec(_) do
		Supervisor.child_spec(
			Registry,
			id: __MODULE__
			start: {__MODULE__, :start_link, []}
		)
	end
snippet impl
	@impl true
	def ${1:name} do
		${0}
	end
snippet wl word list
	~w(${0})
snippet al atom list
	~w(${0})a
snippet date date
	~D[${1}-${2}-${3}]${0}
snippet handlecall
	@impl true
	def handle_call(${1:req}, _from, state) do
		${0}
	end
snippet childspec
	def child_spec(${1:_args}) do
		%{
			id: __MODULE__,
			start: {__MODULE__, :start_link, [${2:args}]},
			type: ${3::worker|:supervisor},
			restart: ${4::permanent|:transient|:temporary},
			shutdown: ${5::shutdown|5000ms}
		}
	end
	${0}
snippet startlinkvia
	def start_link(key) do
		GenServer.start_link(
			__MODULE__,
			${1:nil},
			name: Todo.Server.Registry.via_tuple(key)
		)
	end
	${0}
############################ PHOENIX ##############################
snippet pipe "pipeline"
	pipeline :${1:browser} do
		$0
	end

snippet pipe "pipe_through"
	pipe_through :${1:browser}

snippet get "GET route"
	get "${1:/}", ${2:Project}Controller, :${3:index}

snippet post "POST route"
	post "${1:/}", ${2:Project}Controller, :${3:create}

snippet put "PUT route"
	put "${1:/}", ${2:Project}Controller, :${3:update}

snippet delete "DELETE route"
	delete "${1:/}", ${2:Project}Controller, :${3:destroy}

snippet res "resources route"
	resources "/${1:projects}", ${2:Project}Controller

snippet res "resource route"
	resource "/${1:project}", ${2:Project}Controller

snippet scope "routing scope"
	scope "${1:/}", ${2:MyApp} do
		$0
	end

snippet socket "socket route"
	socket "/${1:ws}", ${2:MyApp} do
		$0
	end

snippet channel "socket channel route"
	channel "${1:notifications}", ${2:Notification}Channel

snippet redirect "redirect(conn, to: ...)"
	redirect(${1:${2:conn}, }to: ${3:${4:project}_path(${5:conn}, :${6:index})})

snippet render "render(conn, view, assigns)"
	render(${1:${2:conn}, }, "${3:view}"${4:, $5})

snippet live
	live "/${1:path}", ${2:ModuleName}, ${3:_action}

snippet mount "liveview init mount function"
	def mount(${1:_params}, ${2:_session}, socket) do
		{:ok, $3}
	end

snippet assign
	assign(socket, ${1:KeyWordList})

snippet liveview
	defmodule ${1:ProjName}Web.${2:LiveViewName} do
		use $1, :live_view
	end

snippet handleevent
	def handle_event("${1:event}", ${2:payload_map}, socket) do

		{
			:noreply,
			assign(
				socket,
				$3
			)
		}
	end

snippet attr
	attr :${1:attr_name}, :${2:attr_type}${3:, opts}
snippet H
	~H"$0"

### MVC ###

snippet controller
	defmodule ${1:App}Web.${2:Page}Controller do
		use $1Web, :controller
		
		$0
	end

# Phoenix Controller Action
snippet action "Create a controller action"
	def ${1:action_name}(conn, ${2:params}) do
		${3:# Process params}
		render(conn, :$1${4:, data: data})
	end
snippet view
	defmodule ${1:App}Web.${2:Page}HTML do
		${3:use $1Web, :html}

		${4:embed_templates "this_file_name/*"}
		${5:def action_name(assigns) do
			~H"""
			Hello!
			"""
		end}
	end
